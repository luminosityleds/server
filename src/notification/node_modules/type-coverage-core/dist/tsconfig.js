"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProjectRootNamesAndCompilerOptions = void 0;
const ts = require("typescript");
const fs = require("fs");
const path = require("path");
const fg = require("fast-glob");
const normalize = require("normalize-path");
/**
 * @public
 */
async function getProjectRootNamesAndCompilerOptions(project) {
    const { configFilePath, dirname } = getTsConfigFilePath(project);
    const config = await getTsConfig(configFilePath, dirname);
    const { options: compilerOptions, errors } = ts.convertCompilerOptionsFromJson(config.compilerOptions, config.basePath || dirname);
    if (errors && errors.length > 0) {
        throw errors;
    }
    const rootNames = await getRootNames(config, dirname);
    if (compilerOptions.baseUrl) {
        if (compilerOptions.baseUrl === '.'
            || compilerOptions.baseUrl === '..'
            || compilerOptions.baseUrl.startsWith(`.${path.sep}`)
            || compilerOptions.baseUrl.startsWith(`..${path.sep}`)
            || compilerOptions.baseUrl.startsWith('./')
            || compilerOptions.baseUrl.startsWith('../')) {
            compilerOptions.baseUrl = path.resolve(path.resolve(process.cwd(), dirname), compilerOptions.baseUrl);
        }
    }
    return { rootNames, compilerOptions };
}
exports.getProjectRootNamesAndCompilerOptions = getProjectRootNamesAndCompilerOptions;
function tryToStatFile(filePath) {
    const jsonFilePath = filePath.endsWith('.json') ? filePath : filePath + '.json';
    try {
        return {
            path: jsonFilePath,
            stats: fs.statSync(jsonFilePath),
        };
    }
    catch (_a) {
        if (jsonFilePath === filePath) {
            return undefined;
        }
        try {
            return {
                path: filePath,
                stats: fs.statSync(filePath),
            };
        }
        catch (_b) {
            return undefined;
        }
    }
}
function getTsConfigFilePath(project, fallbackProject) {
    let configFilePath;
    let dirname;
    let projectStats;
    let result = tryToStatFile(project);
    if (result) {
        project = result.path;
        projectStats = result.stats;
    }
    else if (fallbackProject) {
        while (fallbackProject.length > 0) {
            result = tryToStatFile(fallbackProject[0]);
            if (result) {
                project = result.path;
                projectStats = result.stats;
                break;
            }
            else {
                fallbackProject.shift();
            }
        }
    }
    if (projectStats && projectStats.isDirectory()) {
        configFilePath = path.resolve(project, 'tsconfig.json');
        dirname = project;
    }
    else if (projectStats && projectStats.isFile()) {
        configFilePath = project;
        dirname = path.dirname(project);
    }
    else {
        throw new Error("paramter 'project' should be a file or directory.");
    }
    return { configFilePath, dirname };
}
async function getTsConfig(configFilePath, dirname) {
    const configResult = ts.readConfigFile(configFilePath, p => fs.readFileSync(p).toString());
    const config = configResult.error ? {
        extends: undefined,
        compilerOptions: {
            lib: [
                'dom',
                'es5',
                'es2015',
                'es2016',
                'es2017'
            ],
            allowSyntheticDefaultImports: true
        }
    } : configResult.config;
    if (config.extends) {
        let project;
        let fallbackProjects = [];
        if (path.isAbsolute(config.extends)) {
            project = config.extends;
        }
        else if (config.extends === '.'
            || config.extends === '..'
            || config.extends.startsWith(`.${path.sep}`)
            || config.extends.startsWith(`..${path.sep}`)
            || config.extends.startsWith('./')
            || config.extends.startsWith('../')) {
            project = path.resolve(dirname, config.extends);
        }
        else {
            project = path.resolve(dirname, 'node_modules', config.extends);
            const paths = await findParentsWithNodeModules(dirname);
            fallbackProjects = paths.map(p => path.resolve(p, 'node_modules', config.extends || ''));
        }
        const { configFilePath, dirname: extendsBasename } = getTsConfigFilePath(project, fallbackProjects);
        const extendsConfig = await getTsConfig(configFilePath, extendsBasename);
        const topLevelBaseUrl = config.compilerOptions ? config.compilerOptions.baseUrl : undefined;
        config.compilerOptions = { ...extendsConfig.compilerOptions, ...config.compilerOptions };
        config.basePath = topLevelBaseUrl ? dirname : extendsBasename;
    }
    return config;
}
async function getRootNames(config, dirname) {
    var _a, _b, _c;
    // https://www.typescriptlang.org/tsconfig#include
    let include;
    if (config.include) {
        include = config.include;
    }
    else {
        include = config.files ? [] : ['**/*'];
    }
    // https://www.typescriptlang.org/tsconfig#files
    const files = (_b = (_a = config.files) === null || _a === void 0 ? void 0 : _a.map(f => path.resolve(dirname, f))) !== null && _b !== void 0 ? _b : [];
    if (Array.isArray(include) && include.length > 0) {
        // https://www.typescriptlang.org/tsconfig#exclude
        let exclude;
        if (config.exclude) {
            exclude = config.exclude;
        }
        else {
            exclude = ['node_modules', 'bower_components', 'jspm_packages'];
            if ((_c = config.compilerOptions) === null || _c === void 0 ? void 0 : _c.outDir) {
                exclude.push(config.compilerOptions.outDir);
            }
        }
        // https://github.com/mrmlnc/fast-glob#how-to-exclude-directory-from-reading
        let ignore = [];
        for (const e of exclude) {
            ignore.push(e, `**/${e}`);
        }
        let rules = [];
        for (const file of include) {
            const currentPath = path.resolve(dirname, file);
            const stats = await statAsync(currentPath);
            if (stats === undefined || stats.isFile()) {
                rules.push(currentPath);
            }
            else if (stats.isDirectory()) {
                rules.push(`${currentPath.endsWith('/') ? currentPath.substring(0, currentPath.length - 1) : currentPath}/**/*`);
            }
        }
        rules = rules.map((r) => normalize(r));
        ignore = ignore.map((r) => normalize(r));
        const includeFiles = await fg(rules, {
            ignore,
            cwd: dirname,
        });
        files.push(...includeFiles);
    }
    return files.map((r) => path.resolve(process.cwd(), dirname, r));
}
function statAsync(file) {
    return new Promise((resolve) => {
        fs.stat(file, (error, stats) => {
            if (error) {
                resolve(undefined);
            }
            else {
                resolve(stats);
            }
        });
    });
}
async function findParentsWithNodeModules(dir) {
    const result = [process.cwd()];
    dir = path.resolve(dir);
    for (let i = 0; i < 3; i++) {
        dir = path.dirname(dir);
        const stats = await statAsync(path.resolve(dir, 'node_modules'));
        if (stats && stats.isDirectory() && !result.includes(dir)) {
            result.push(dir);
        }
    }
    return result;
}
